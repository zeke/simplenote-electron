Document
	= ls:(l:Line Newline { return l })* l:Line { return ls.concat( l ) }
    
Line
	= Header
    / BlockQuote
    / ToDoItem
    / BulletItem
    / ts:Token*
    {
        const tokens = ts.reduce(
        	function(out, next) {
            	return typeof next === 'string' && typeof out[1] === 'string'
                	? [ out[0].slice(0, -1).concat( out[0].slice(-1).concat( next ).join('') ), next ]
                    : [ out[0].concat( next ), next ];
            },
            [[], undefined]
        )
        
        return tokens[0].map( function( token ) {
        	const value = typeof token === 'string'
            	? { type: 'text', text: token }
                : token;
            
            return Object.assign( { location: location() }, value )
        } )
    }
    
Header
	= l:'#'+ h:[^\n]*
    ! { l.length <= 6 }
    { return { type: 'header', level: l.length, text: h.join(''), location: location() } }
    
BlockQuote
	= '>' l:([ \t]* b:'>')* [ \t]* q:[^\n]+ { return { type: 'blockquote', text: q.join(''), level: 1 + l.length, location: location() } }
    
BulletItem
	= [ \t]+ [-*] ' ' s:[^\n]+ { return { type: 'list-bullet', text: s.join( '' ), location: location() } }
    
ToDoItem
	= [ \t]+ '- [' isDone:[xX]? isNotDone:' '? ']' [ \t]+ t:[^\n]+ { return { type: 'todo', isDone: !! isDone, text: t.join(''), location: location() } }

Token
	= Strong
    / Emphasized
    / StrikeThrough
    / InlineCode
    / AtMention
    / HtmlLink
    / MarkdownLink
    / Url
    / [^\n]
    
Strong
	= '**' s:[^*]+ '**' { return { type: 'strong', text: s.join(''), location: location() } }
    / '__' s:[^_]+ '__' { return { type: 'strong', text: s.join(''), location: location() } }
    
Emphasized
	= '*' s:[^*]+ '*' { return { type: 'em', text: s.join(''), location: location() } }
    / '_' s:[^_]+ '_' { return { type: 'em', text: s.join(''), location: location() } }
    
StrikeThrough
	= '~~' s:[^~]+ '~~' { return { type: 'strike', text: s.join(''), location: location() } }

InlineCode
	= '`' s:[^`]+ '`' { return { type: 'code-inline', text: s.join(''), location: location() } }
    
AtMention
	= '@' head:[a-zA-Z] tail:[a-zA-Z0-9]* { return { type: 'at-mention', text: [head].concat(tail).join(''), location: location() } }
    
Url
	= scheme:UrlScheme '://' host:UrlHost slash:'/'? path:UrlPath?
    { return {
    	type: 'link',
        text: '',
        href: {
        	url: scheme + '://' + [ host, slash, path ].join(''),
            location: location()
        },
        location: location()
    } }
    
UrlScheme
	= s:[a-z] ss:[a-z0-9+\.\-]+ { return s + ss.join('') }
    
UrlHost
	= pp:UrlHostPart ps:('.' p:UrlHostPart { return p })* { return [pp].concat( ps ).join('.') }
    
UrlHostPart
    = cs:[0-9a-z\-_~]+ { return cs.join('') }

UrlPath
	= ps:(p:UrlPathPart t:'/'? { return [p, t].join('') })+ { return ps.join('') }

UrlPathPart
	= c:UrlPathChar+ cs:('.' ccs:UrlPathChar+ { return '.' + ccs.join('') })* { return [c.join('')].concat( cs ).join('') }

UrlPathChar
	= [a-z0-9\-_~]
    
HtmlLink
	= '<a' [ ]+ as:(a:HtmlAttribute [ ]+ { return a })* a:HtmlAttribute? '/'? '>' text:[^<]+ '</a>'
    { return {
    	type: 'link',
        text: text.join(''),
        href: {
        	url: as.concat( a ).find( a => 'href' === a.name ).value,
            location: as.concat( a ).find( a => 'href' === a.name ).location
		}
    } }
    
HtmlAttribute
	= name:[a-zA-Z]+ '=' value:(v:QuotedString { return { v: v.s, l: v.l } }) { return { name: name.join(''), value: value.v, location: value.l } }
    
QuotedString
	= '"' string:(s:[^"]* { return { v: s.join(''), l: location() } }) '"' { return { s: string.v, l: string.l } }
    
MarkdownLink
	= '[' text:[^\]]* '](' href:(url:[^\)]+ { return { url: url, location: location() } }) ')'
    { return {
    	type: 'link',
        text: text.join( '' ),
        href: { url: href.url.join( '' ), location: href.location }
    } }
    
Newline
	= [\n]


